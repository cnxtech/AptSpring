<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DefinitionContentInspector.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">AptSpringProcessor</a> &gt; <a href="../index.html" class="el_bundle">AptSpringModel</a> &gt; <a href="index.source.html" class="el_package">com.salesforce.apt.graph.processing</a> &gt; <span class="el_source">DefinitionContentInspector.java</span></div><h1>DefinitionContentInspector.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2017, Saleforce.com, Inc
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the &lt;organization&gt; nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.salesforce.apt.graph.processing;

import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.jgrapht.DirectedGraph;
import org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;

import com.salesforce.apt.graph.model.AbstractModel;
import com.salesforce.apt.graph.model.BaseInstanceModel;
import com.salesforce.apt.graph.model.DefinitionModel;
import com.salesforce.apt.graph.model.ExpectedModel;
import com.salesforce.apt.graph.model.InstanceDependencyModel;
import com.salesforce.apt.graph.model.InstanceModel;
import com.salesforce.apt.graph.model.errors.ErrorModel;
import com.salesforce.apt.graph.model.errors.ErrorType;
import com.salesforce.apt.graph.model.storage.DefinitionModelStore;
import com.salesforce.apt.graph.types.AssignabilityUtils;

<span class="fc" id="L58">public class DefinitionContentInspector {</span>

  public void inspectDefinitionGraph(Set&lt;DefinitionModel&gt; definitionGraphHeads,
      Consumer&lt;ErrorModel&gt; errorListener, AssignabilityUtils assignabilityUtils, DefinitionModelStore store) {
<span class="fc bfc" id="L62" title="All 2 branches covered.">    for (DefinitionModel definition : definitionGraphHeads) {</span>
<span class="fc" id="L63">      depthFirstExpectedsInspector(definition, errorListener, assignabilityUtils, store);</span>
    }
<span class="fc" id="L65">  }</span>
  
  public InstanceModel getOneWithSourceElementElseAny(final Collection&lt;InstanceModel&gt; possibilities) {
<span class="nc" id="L68">    return possibilities.stream()</span>
<span class="nc" id="L69">         .filter(im -&gt; im.getSourceElement().isPresent())</span>
<span class="nc" id="L70">         .findAny().orElseGet(() -&gt; possibilities.iterator().next());</span>
  }
  
  public boolean verifiedShas(DefinitionModel model, DefinitionModelStore store) {
<span class="fc" id="L74">    boolean verified = true;</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">    for (Entry&lt;String, String&gt; depNameToSha256 : model.getDependencyNameToSha256().entrySet()) {</span>
<span class="nc" id="L76">      DefinitionModel dep = store.lookup(depNameToSha256.getKey()).get(0);</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      if (model.getDependencyNameToSha256().get(dep.getIdentity()) != null) {</span>
<span class="nc bnc" id="L78" title="All 4 branches missed.">        verified = verified &amp;&amp; verifiedShas(dep, store); </span>
<span class="nc bnc" id="L79" title="All 4 branches missed.">        verified = verified &amp;&amp; model.getDependencyNameToSha256().get(dep.getIdentity()).equals(dep.getSha256());</span>
      }
    }
<span class="fc" id="L82">    return verified;</span>
  }
  
  
  /**
   * Verify that all expected entities are marked expected.
   * Verify that the types of provided entities satisfy all expected types....
   * &lt;p/&gt;
   * if a child record was freshly process, so too must all parent ( if the md5 has changed ).
   *  
   * @param definition the head of current tree of definitions linked by imports
   * @param errorListener registers all errors found 
   */
  private boolean depthFirstExpectedsInspector(DefinitionModel definition, Consumer&lt;ErrorModel&gt; errorListener,
      AssignabilityUtils assignabilityUtils, DefinitionModelStore store) {
<span class="fc" id="L97">    boolean errored = false;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">    for (DefinitionModel dependency : definition.getDependencies()) {</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">      if (!dependency.isLockedAnalyzed()) {</span>
<span class="pc bpc" id="L100" title="2 of 4 branches missed.">        errored = depthFirstExpectedsInspector(dependency, errorListener, assignabilityUtils, store) || errored;</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (errored) {</span>
<span class="nc" id="L102">          return true; // no need to continue.</span>
        }
      } else {
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (!verifiedShas(dependency, store)) {</span>
<span class="nc" id="L106">          errored = true;</span>
<span class="nc" id="L107">          errorListener.accept(</span>
<span class="nc" id="L108">              new ErrorModel(ErrorType.DEPENDENCY_SHA_MISMATCH, Arrays.asList(dependency), Arrays.asList(definition)));</span>
        }
      }
    }
    
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">    if (errored) {</span>
<span class="nc" id="L114">      return errored;</span>
    }
    
    //check that each object has only one source ( could be the imported from a dependency, in a diamond pattern )
    //validate the expected beans are correct.
<span class="fc" id="L119">    Map&lt;String, InstanceModel&gt; resolvedInstances = ensureSingleInstanceOfEachName(definition, errorListener);</span>
    
    //short circuit if dependencies couldn't be resolved.
<span class="fc bfc" id="L122" title="All 2 branches covered.">    if (resolvedInstances == null) {</span>
<span class="fc" id="L123">      return false;</span>
    }
    
    //looks for cycles and unexpected missing entities.
<span class="fc" id="L127">    errored = detectCyclesInEntityGraph(definition, resolvedInstances, errorListener);</span>

    //check types of non-expected dependencies
<span class="fc bfc" id="L130" title="All 4 branches covered.">    errored = checkInstancesTypesInDefinition(definition, resolvedInstances, errorListener, assignabilityUtils) || errored;</span>

    //check all definitions with expected, that each instance expecting a definition can use the supplied.
<span class="fc bfc" id="L133" title="All 4 branches covered.">    errored = checkProvidedSupplyCorrectTypes(definition, resolvedInstances, errorListener, assignabilityUtils) || errored;</span>

    //prune all edged from graph that don't end in an expected

    //store computed expects with all types that must satisfied.
    
    
    
<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (!errored) {</span>
      //store as provided dependencies
<span class="fc" id="L143">      definition.addAllProvidedInstances(resolvedInstances.values());</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">      for (DefinitionModel dep : definition.getDependencies()) {</span>
<span class="fc" id="L145">        definition.addDependencyNameToSha256(dep.getIdentity(), dep.getSha256());</span>
      }
      //storing will lock a the definition, as will reading.
<span class="fc bfc" id="L148" title="All 2 branches covered.">      if (!store.store(definition)) {</span>
<span class="fc" id="L149">        errorListener.accept(</span>
<span class="fc" id="L150">            new ErrorModel(ErrorType.COULD_NOT_STORE, Arrays.asList(definition), Arrays.asList(definition)));</span>
      }
    }
    
<span class="fc" id="L154">    return errored;</span>
  }

  private ErrorModel errorForMismatchedExpected(final DefinitionModel definition, ExpectedModel computedExpected,
      final Map&lt;String, InstanceModel&gt; nameToEntity, AssignabilityUtils assignabilityUtils) {
    //that which is to fill all the expectedInstance references.
<span class="fc" id="L160">    InstanceModel providedInstance = nameToEntity.get(computedExpected.getIdentity());</span>
    
    //the top level definition model should have declared this an expectedBean - maybe move that error here?
<span class="fc bfc" id="L163" title="All 2 branches covered.">    if (providedInstance == null) {</span>
<span class="fc" id="L164">      return null;</span>
    }
    
    //Instances which expect to use the provided instance
<span class="fc" id="L168">    List&lt;InstanceModel&gt; mistmatchedExpectantEntities = computedExpected.getDefinitionReferenceToType().keySet().stream()</span>
<span class="fc" id="L169">        .map(name -&gt; nameToEntity.get(name))</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        .filter(expectantInstance -&gt; !assignabilityUtils.isAssignableFrom(providedInstance, expectantInstance))</span>
<span class="fc" id="L171">        .collect(Collectors.toList());</span>
    
<span class="fc bfc" id="L173" title="All 2 branches covered.">    if (mistmatchedExpectantEntities.size() == 0) {</span>
<span class="fc" id="L174">      return null;</span>
    } else {
<span class="fc" id="L176">      List&lt;InstanceModel&gt; involved = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L177">      involved.add(providedInstance);</span>
<span class="fc" id="L178">      involved.addAll(mistmatchedExpectantEntities);</span>
<span class="fc" id="L179">      return new ErrorModel(ErrorType.UNMATCHED_TYPES, involved, Arrays.asList(definition, providedInstance));</span>
    }
  }
  
  private boolean checkProvidedSupplyCorrectTypes(final DefinitionModel definition, final Map&lt;String, InstanceModel&gt; nameToEntity,
      final Consumer&lt;ErrorModel&gt; errorListner, AssignabilityUtils assignabilityUtils) {
<span class="fc" id="L185">    List&lt;ErrorModel&gt; errors = definition.getDependencies().stream()</span>
<span class="fc" id="L186">        .flatMap(dependency -&gt; dependency.getComputedExpected().stream())</span>
<span class="fc" id="L187">        .filter(expectedModel -&gt; !definition.getExpectedDefinitions().stream()</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">            .anyMatch(ed -&gt; ed.getIdentity().equals(expectedModel.getIdentity())))</span>
<span class="fc" id="L189">        .map(em -&gt; errorForMismatchedExpected(definition, em, nameToEntity, assignabilityUtils))</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        .filter(errorModel -&gt; errorModel != null)</span>
<span class="fc" id="L191">        .collect(Collectors.toList());</span>
<span class="fc" id="L192">    errors.stream().forEach(errorListner);</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">    return errors.size() &gt; 0;</span>
  }
  
  
  private List&lt;Entry&lt;String, InstanceModel&gt;&gt; getEntryListForNameAndAlias(InstanceModel instanceModel) {
<span class="fc" id="L198">    List&lt;Entry&lt;String, InstanceModel&gt;&gt; output = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L199">    output.add(new SimpleEntry&lt;&gt;(instanceModel.getIdentity(), instanceModel));</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">    for (String alias : instanceModel.getAliases()) {</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">      if (!alias.equals(instanceModel.getIdentity())) {</span>
<span class="fc" id="L202">        output.add(new SimpleEntry&lt;&gt;(alias, instanceModel));</span>
      }
    }
<span class="fc" id="L205">    return output;</span>
  }
  
  /**
   * Verify that a single named instance model is correctly identifiable composed of owningDefinition/ElementLocation/Identity.
   * 
   * 
   * @param definition the definition of 
   * @param errorListener accepts and displays all errors produced by analyzing the models.
   * @return returns a map of each instance name to the single model that the has been resolved to. 
   */
  private Map&lt;String, InstanceModel&gt; ensureSingleInstanceOfEachName(DefinitionModel definition,
      Consumer&lt;ErrorModel&gt; errorListener) {
<span class="fc" id="L218">    Map&lt;String, Map&lt;String, InstanceModel&gt;&gt; instancesByNameAndLocationDedupped = </span>
<span class="fc" id="L219">        definitionToAllInstancesByNameAndSourceLocation(definition);</span>
    
<span class="fc" id="L221">    final Map&lt;String, InstanceModel&gt; resolvedDependencies = new HashMap&lt;&gt;();</span>
<span class="fc" id="L222">    boolean errored = false;    </span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">    for (Entry&lt;String, Map&lt;String, InstanceModel&gt;&gt; entry : instancesByNameAndLocationDedupped.entrySet()) {</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">      if (entry.getValue().size() == 1) {</span>
<span class="fc" id="L225">        resolvedDependencies.put(entry.getKey(), entry.getValue().values().iterator().next()); //get only InstanceModel.</span>
<span class="fc" id="L226">      } else {</span>
<span class="fc" id="L227">        errored = true;</span>
<span class="fc" id="L228">        errorListener.accept(errorForDuplicateInstanceModels(definition, entry.getValue().values().stream()</span>
<span class="fc" id="L229">            .sorted((i1, i2) -&gt; i1.getElementLocation().compareTo(i2.getElementLocation()))</span>
<span class="fc" id="L230">            .collect(Collectors.toList())));</span>
      }
    }
<span class="fc bfc" id="L233" title="All 2 branches covered.">    return errored ? null : resolvedDependencies;</span>
  }
  
  /**
   * Give a definition model, extract all instances from this definition, and all imported definitions.
   * Group the instances by name, and then map them from source location to InstanceModel.
   *  
   * @param definition model to extract all instance information from, including imported definitions.
   * @return a map of maps, [name -&gt; [sourceLocation -&gt; instanceModel]]
   */
  private Map&lt;String, Map&lt;String, InstanceModel&gt;&gt; definitionToAllInstancesByNameAndSourceLocation(
      DefinitionModel definition) {
    //create a stream of all imported Definition's InstanceModels
<span class="fc" id="L246">    Stream&lt;InstanceModel&gt; imported = definition.getDependencies().stream()</span>
<span class="fc" id="L247">        .map(d -&gt; d.getProvidedInstances()).flatMap(x -&gt; x.stream());</span>
    //merge the stream with all local instance models.
<span class="fc" id="L249">    Stream&lt;InstanceModel&gt; instanceModelStream = Stream.concat(definition.getObjectDefinitions().stream(), imported);</span>

    //map all instances by name and then by source location (due to diamond dependencies in definition imports.
<span class="fc" id="L252">    Map&lt;String, Map&lt;String, InstanceModel&gt;&gt; instancesByNameAndLocationDedupped = instanceModelStream</span>
<span class="fc" id="L253">        .flatMap(instance -&gt; getEntryListForNameAndAlias(instance).stream()) //flat map all alias to entries</span>
<span class="fc" id="L254">        .collect(Collectors.groupingBy(entry -&gt; entry.getKey(), //group by name</span>
<span class="fc" id="L255">            Collectors.mapping(entry -&gt; entry.getValue(), </span>
<span class="fc" id="L256">                Collectors.toMap(im -&gt; im.getElementLocation(), //by location</span>
<span class="fc" id="L257">                    im -&gt; im, //identity function for first insert</span>
                    //choose the one with source element on merge, if any
<span class="pc bnc" id="L259" title="All 2 branches missed.">                    (im1, im2) -&gt; im1.getSourceElement().isPresent() ? im1 : im2))));</span>
<span class="fc" id="L260">    return instancesByNameAndLocationDedupped;</span>
  }

  /**
   * Given a list of duplicate instance models (same identifier, different source elements) produce a 
   * well formed ErrorModel.
   * 
   * @param definition where the error was first detected.
   * @param causes the list of all instances models from the definition or any of it's imported definitions.
   * @return an well formed ErrorModel of the duplicated beans.
   */
  private ErrorModel errorForDuplicateInstanceModels(DefinitionModel definition, List&lt;InstanceModel&gt; causes) {
<span class="fc" id="L272">    ArrayList&lt;AbstractModel&gt; involved = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L273">    involved.add(definition);</span>
<span class="fc" id="L274">    involved.addAll(causes.stream()</span>
<span class="fc" id="L275">        .filter(instanceModel -&gt; instanceModel.getSourceElement().isPresent())</span>
<span class="fc" id="L276">        .collect(Collectors.toList()));</span>
<span class="fc" id="L277">    return new ErrorModel(ErrorType.DUPLICATE_OBJECT_DEFINITIONS, causes, involved);</span>
  }
  
  /**
   * Inspects the instance graph for cycles, any cycle is printed as an error.   The nameToEntity parameter doesn't list expected
   * instances, any instances that are not found in the nameToInstances map (they are looked for because they are referenced as a
   * dependency by an instance in the map) and are not found by name in the definition's expectedInstances are treated as errors
   * as well.
   * 
   * @param definition definition being processed.  Will uses it's expected list, any instances references as dependencies but
   *     not found, not listed as expected in this DefinitionModel, will be treated as errors.
   * @param nameToEntity name to unique instanceModels, verified before call.
   * @param errorListner accepts and displays all errors produced by analyzing the models
   * @return true if an error occurred, false otherwise
   */
  private boolean detectCyclesInEntityGraph(final DefinitionModel definition, final Map&lt;String, InstanceModel&gt; nameToEntity,
      final Consumer&lt;ErrorModel&gt; errorListener) {
<span class="fc" id="L294">    final Map&lt;String, ExpectedModel&gt; missing = new HashMap&lt;&gt;();</span>
<span class="fc" id="L295">    final DirectedGraph&lt;BaseInstanceModel, DefaultEdge&gt; entityGraph = new DefaultDirectedGraph&lt;&gt;(DefaultEdge.class);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">    for (BaseInstanceModel entity : nameToEntity.values()) {</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">      if (!entityGraph.containsVertex(entity)) {</span>
<span class="fc" id="L298">        entityGraph.addVertex(entity);</span>
      }
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">      if (InstanceModel.class.isAssignableFrom(entity.getClass())) {</span>
<span class="fc" id="L301">        InstanceModel instanceModel = (InstanceModel) entity;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        for (InstanceDependencyModel instanceDependency : instanceModel.getDependencies()) {</span>
<span class="fc" id="L303">          BaseInstanceModel dependency = nameToEntity.get(instanceDependency.getIdentity());</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">          if (dependency == null) {</span>
<span class="fc" id="L305">            dependency = missing.computeIfAbsent(instanceDependency.getIdentity(), s -&gt; new ExpectedModel(s));</span>
<span class="fc" id="L306">            missing.get(instanceDependency.getIdentity())</span>
<span class="fc" id="L307">              .addDefinitionReferenceToType(instanceModel.getIdentity(), instanceDependency.getType());</span>
          }
<span class="fc bfc" id="L309" title="All 2 branches covered.">          if (!entityGraph.containsVertex(dependency)) {</span>
<span class="fc" id="L310">            entityGraph.addVertex(dependency);</span>
          }
<span class="fc" id="L312">          entityGraph.addEdge(entity, dependency);</span>
        }
      }
    }
    
<span class="fc" id="L317">    boolean errored = errorsForCycles(errorListener, entityGraph);</span>
<span class="fc bfc" id="L318" title="All 4 branches covered.">    errored = testAllMissingEntitiesAreExpected(definition, errorListener, missing, entityGraph) || errored;</span>
<span class="fc bfc" id="L319" title="All 4 branches covered.">    errored = errorUnusedExpectedsOnDefinition(definition, errorListener, missing) || errored;</span>
<span class="fc" id="L320">    return errored;</span>
  }

  private boolean checkInstancesTypesInDefinition(final DefinitionModel definition, final Map&lt;String, InstanceModel&gt; nameToEntity,
      final Consumer&lt;ErrorModel&gt; errorListner, AssignabilityUtils assignabilityUtils) {
<span class="fc" id="L325">    boolean errored = false;</span>
<span class="fc" id="L326">    List&lt;InstanceModel&gt; instances = definition.getObjectDefinitions();</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">    for (InstanceModel instance : instances) {</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">      for (InstanceDependencyModel instanceDependency : instance.getDependencies()) {</span>
<span class="fc" id="L329">        InstanceModel dependency = nameToEntity.get(instanceDependency.getIdentity());</span>
<span class="fc bfc" id="L330" title="All 4 branches covered.">        if (dependency != null &amp;&amp; !assignabilityUtils.isAssignableFrom(dependency, instance)) {</span>
<span class="fc" id="L331">          errored = true;</span>
<span class="fc" id="L332">          errorListner.accept(new ErrorModel(ErrorType.UNMATCHED_TYPES,</span>
<span class="fc" id="L333">              Arrays.asList(instance, dependency), Arrays.asList(instance, dependency)));</span>
        }
      }
    }
<span class="fc" id="L337">    return errored;</span>
  }

  private boolean errorUnusedExpectedsOnDefinition(final DefinitionModel definition, final Consumer&lt;ErrorModel&gt; errorListner,
      final Map&lt;String, ExpectedModel&gt; missing) {
<span class="fc" id="L342">    boolean errored = false;</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">    for (ExpectedModel expected : definition.getExpectedDefinitions()) {</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">      if (!missing.keySet().contains(expected.getIdentity())) {</span>
<span class="fc" id="L345">        errorListner.accept(new ErrorModel(ErrorType.UNUSED_EXPECTED, Arrays.asList(expected), Arrays.asList(definition)));</span>
<span class="fc" id="L346">        errored = true;</span>
      }
    }
<span class="fc" id="L349">    return errored;</span>
  }

  private boolean errorsForCycles(final Consumer&lt;ErrorModel&gt; errorListner,
      final DirectedGraph&lt;BaseInstanceModel, DefaultEdge&gt; entityGraph) {
<span class="fc" id="L354">    SzwarcfiterLauerSimpleCycles&lt;BaseInstanceModel, DefaultEdge&gt; cycleFind = new SzwarcfiterLauerSimpleCycles&lt;&gt;();</span>
<span class="fc" id="L355">    boolean errored = false;</span>
<span class="fc" id="L356">    cycleFind.setGraph(entityGraph);</span>
<span class="fc" id="L357">    List&lt;List&lt;BaseInstanceModel&gt;&gt; cycles = cycleFind.findSimpleCycles();</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">    for (List&lt;BaseInstanceModel&gt; cycle : cycles) {</span>
<span class="fc" id="L359">      errored = true;</span>
<span class="fc" id="L360">      errorListner.accept(new ErrorModel(ErrorType.CYCLE_IN_DEFINITION_SOURCES, cycle, cycle));</span>
    }
<span class="fc" id="L362">    return errored;</span>
  }

  private boolean testAllMissingEntitiesAreExpected(final DefinitionModel definition, final Consumer&lt;ErrorModel&gt; errorListner,
      final Map&lt;String, ExpectedModel&gt; missing, final DirectedGraph&lt;BaseInstanceModel, DefaultEdge&gt; entityGraph) {
    //check computed expected are actually expected
<span class="fc" id="L368">    boolean errored = false;</span>
<span class="fc" id="L369">    List&lt;String&gt; expectedMissing = definition.getExpectedDefinitions().stream().map(em -&gt; em.getIdentity())</span>
<span class="fc" id="L370">        .collect(Collectors.toList());</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">    for (ExpectedModel expected : missing.values()) {</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">      if (!expectedMissing.contains(expected.getIdentity())) {</span>
<span class="fc" id="L373">        List&lt;AbstractModel&gt; dependsOnMissing = Stream.concat(</span>
<span class="fc" id="L374">            Stream.of(definition), </span>
<span class="fc" id="L375">            entityGraph.incomingEdgesOf(expected).stream().map(edge -&gt; entityGraph.getEdgeSource(edge))</span>
<span class="fc" id="L376">              .filter(m -&gt; m.getSourceElement().isPresent()))</span>
<span class="fc" id="L377">            .collect(Collectors.toList());</span>
<span class="fc" id="L378">        errored = true;</span>
<span class="fc" id="L379">        errorListner.accept(new ErrorModel(ErrorType.MISSING_BEAN_DEFINITIONS, Arrays.asList(expected), dependsOnMissing));</span>
<span class="fc" id="L380">      } else {</span>
<span class="fc" id="L381">        definition.addComputedExpected(expected);</span>
      }
    }
<span class="fc" id="L384">    return errored;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>